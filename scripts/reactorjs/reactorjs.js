const global="undefined"!=typeof exports&&null!==exports?exports:this,dependencyStack=[],coreExtractor=new WeakMap;let batcher=null;class Definition{constructor(a){if("function"==typeof a)return this.definition=a,this;throw new TypeError("Cannot create definition with a non-function")}}const define=a=>new Definition(a),Signals=new WeakSet;class Signal{constructor(b){let c={read(){let c=dependencyStack[dependencyStack.length-1];c&&(this.dependents.add(c),c.dependencies.add(this));let a=this.value instanceof Definition?this.value.definition():this.value;if(Reactors.has(a))return a;let b=this.reactorCache.get(a);if(b)return b;try{return b=new Reactor(a),this.reactorCache.set(a,b),b}catch(d){if("TypeError"===d.name)return a;throw d}},write(b){if(this.value===b)return this.value=b;let c=this.value=b,a=[];if(Array.from(this.dependents).forEach(b=>{try{batcher?batcher.add(b):b.trigger()}catch(c){a.push(c)}}),1===a.length)throw a[0];if(a.length>1){let d="Multiple errors from signal write";throw new CompoundError(d,a)}return c},removeDependent(a){this.dependents.delete(a),0===this.dependents.size&&this.removeSelf()}},a=function(a){return 0===arguments.length?c.read():c.write(a)};return coreExtractor.set(a,c),Signals.add(a),a(b),a}}const Reactors=new WeakSet;class Reactor{constructor(b){0===arguments.length&&(b={});let c={source:b,selfSignal:new Signal(null),apply(a,b){return batch(()=>Reflect.apply(this.source,a,b))},getSignals:{},get(a,d){let b=Object.getOwnPropertyDescriptor(this.source,a);if(b&&!b.writable&&!b.configurable)return Reflect.get(this.source,a,d);this.getSignals[a]=this.getSignals.hasOwnProperty(a)?this.getSignals[a]:new Signal;let c=coreExtractor.get(this.getSignals[a]);c.removeSelf=()=>delete this.getSignals[a];let e=Reflect.get(this.source,a,d);return c.value=e,c.read()},defineProperty(b,a){if(a.value instanceof Definition){let c={get:a.value.definition,configurable:void 0===a.configurable||a.configurable,enumerable:void 0===a.enumerable||a.enumerable};(a.writable|| void 0===a.writable)&&(c.set=a=>{delete this.source[b],this.source[b]=a}),a=c}let d=Reflect.defineProperty(this.source,b,a);return this.trigger(b),d},deleteProperty(a){let b=Reflect.deleteProperty(this.source,a);return this.trigger(a),b},hasSignals:{},has(a){this.hasSignals[a]=this.hasSignals.hasOwnProperty(a)?this.hasSignals[a]:new Signal(null);let b=coreExtractor.get(this.hasSignals[a]);b.removeSelf=()=>delete this.hasSignals[a];let c=Reflect.has(this.source,a);return b.value=c,b.read()},ownKeys(){let b=Reflect.ownKeys(this.source),a=coreExtractor.get(this.selfSignal);return a.value=b,a.read()},trigger(a){let b=Reflect.get(this.source,a),c=Reflect.has(this.source,a),d=Reflect.ownKeys(this.source),e=coreExtractor.get(this.selfSignal).value,f=(()=>{let a=new Set(d),b=new Set(e);if(a.size!==b.size)return!0;for(let c of a)if(!b.has(c))return!0;return!1})();batch(()=>{this.getSignals[a]&&this.getSignals[a](b),this.hasSignals[a]&&this.hasSignals[a](c),f&&this.selfSignal(d)})}},a=new Proxy(c.source,{apply(a,b,d){if(a===c.source)return c.apply(b,d);throw new Error("Proxy target does not match initialized object")},get(a,b,d){if(a===c.source)return c.get(b,d);throw new Error("Proxy target does not match initialized object")},defineProperty(a,b,d){if(a===c.source)return c.defineProperty(b,d);throw new Error("Proxy target does not match initialized object")},deleteProperty(a,b){if(a===c.source)return c.deleteProperty(b);throw new Error("Proxy target does not match initialized object")},has(a,b){if(a===c.source)return c.has(b);throw new Error("Proxy target does not match initialized object")},ownKeys(a){if(a===c.source)return c.ownKeys();throw new Error("Proxy target does not match initialized object")}});return coreExtractor.set(a,c),Reactors.add(a),a}}global.Reactor=Reactor;const observerRegistry=new Map;class Observer{constructor(b,c,f){if("function"!=typeof c)throw new TypeError("Cannot create observer with a non-function");if(null!=b){let d=observerRegistry.get(b);if(d)return d(c)}let e={execute:c,clearDependencies(){this.dependencies.forEach(a=>a.removeDependent(this)),this.dependencies.clear()},trigger(){if(this.triggering)throw new LoopError("observer attempted to activate itself while already executing");if(this.running){this.clearDependencies(),f?dependencyStack.push(null):dependencyStack.push(this),this.triggering=!0;try{this.execute()}finally{dependencyStack.pop(),this.triggering=!1}}},stop(){this.running=!1,this.clearDependencies()},start(){this.running||(this.running=!0,this.trigger())}},a=function(b){if(0===arguments.length)return e.execute();if("function"!=typeof b)throw new TypeError("Cannot create observer with a non-function");return e.clearDependencies(),e.running=!0,e.triggering=!1,e.execute=b,e.trigger(),a};return a.stop=()=>e.stop(),a.start=()=>e.start(),coreExtractor.set(a,e),void 0!==b&&observerRegistry.set(b,a),e.trigger(),a}}const observe=(b,c)=>{let d,a;return void 0===c?a=b:(d=b,a=c),new Observer(d,a)};global.observe=observe;const unobserve=b=>{let a;return new Observer(null,()=>{a=b()},!0),a};global.unobserve=unobserve;const batch=c=>{let b;if(null===batcher){batcher=new Set,b=c(),batcher=null;let a=[];if(batchedObservers.forEach(b=>{try{b.trigger()}catch(c){a.push(c)}}),1===a.length)throw a[0];if(a.length>1){let d="Multiple errors from batched reactor observers";throw new CompoundError(d,a)}}else b=c();return b};global.batch=batch;class LoopError extends Error{constructor(...a){return super(...a),this.name=this.constructor.name,this}}class CompoundError extends Error{constructor(a,b){for(let c of(a=a+"\n"+(b=b.flatMap(a=>a instanceof CompoundError?a.errorList:a)).length+" errors in total",b)){let d=null!=c.stack?c.stack:c.toString();a=a+"\n"+d}return super(a),this.errorList=b,this.name=this.constructor.name,this}}